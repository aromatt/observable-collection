{"name":"Observable-collection","tagline":"Ruby collections + Observable","body":"# observable-collection\r\nThis is a simple way to add observers to Ruby arrays and hashes.\r\n\r\nUsing nothing but clean, everyday Ruby syntax, you can register callbacks which are called whenever your collection (or any nested collection thereof) is updated.\r\n\r\nObservers of an ObservableCollection receive notifications just before and just after any method is invoked on your collection (or any of its nested collections).\r\n\r\nExample applications:\r\n* Keeping a persistent copy of your collection on disk, which is read and written on every read/write of your collection\r\n* Hiding database interactions behind Ruby data structure manipulations\r\n\r\n## Testing\r\nTo run the tests, run this command:\r\n\r\n    $ ./test/baseline\r\n\r\n## Usage\r\n\r\n### Creating an ObservableCollection\r\nCreate an observable version of any Hash or Array like this:\r\n```ruby\r\nhash = ObservableCollection.create({ foo: 'bar' }, some_observer)\r\n```\r\nwhere `some_observer` is an object with an instance method called `update` (see below for details).\r\n\r\n### Observing\r\nThe observer's `update` method should accept two arguments: (1) the observed collection and (2) a symbol (either `:before` of `:after`), indicating whether the collection is about to be updated (`:before`), or has just been updated (`:after`). For example\r\n```ruby\r\nclass Observer\r\n  def update(item, kind)\r\n    if kind == :after\r\n      puts \"item is about to be updated: #{item}\"\r\n    else\r\n      puts \"item was just updated: #{item}\"\r\n    end\r\n  end\r\nend\r\n```\r\n### Putting it all together\r\nLet's observe a collection!\r\n```ruby\r\nobserver = Observer.new\r\nhash = ObservableCollection.create({ foo: 'bar' }, observer)\r\nhash[:hello] = 'world'\r\n```\r\nOutput:\r\n\r\n    item is about to be updated: {:foo=>\"bar\"}\r\n    item was just updated: {:foo=>\"bar\", :hello=>\"world\"}\r\n\r\nAlternatively, you may simply use ObservableCollection's constructor and add your observer manually:\r\n```ruby\r\nhash = ObservableCollection.new({ foo: 'bar' })\r\nhash.add_observer(Observer.new)\r\n```\r\nNote that you can specify a custom update method name as a symbol, as the second argument to `add_observer`, or as the `:func` option when using the `create` factory method.\r\n\r\nSee the tests (`regress/`) for more examples.\r\n\r\n### Options\r\nThe following options are accepted by both the `create` factory method and the constructor (excluding `:func`).\r\n* `:always_update_after` - `:after` updates only occur when a method known to modify collections is called (e.g. `<<=`, `push`, `pop`, `select!`). To override this behavior so that `:after` updates always occur regardless of the method being invoked, provide the option `:always_update_after => true` to `ObservableCollection.create()`.\r\n* `:lock_file` - the path to a file used for locking access to the collection (currently not fully supported).\r\n* `:func` - a custom update method (symbol) defined by your observer (defaults to `:update`).\r\n\r\n## Future\r\n* Allow callbacks to change the args or even short-circuit invocations.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}